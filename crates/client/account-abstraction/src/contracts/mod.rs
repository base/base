//! EntryPoint Contract Definitions and Simulation Bytecode
//!
//! This module contains:
//! - Solidity ABI definitions for EntryPoint contracts (v0.6, v0.7, v0.8, v0.9)
//! - Simulation bytecode that can be deployed via state overrides
//! - Helper functions for creating state overrides for gas estimation
//!
//! # Version Differences
//!
//! - **v0.6**: `simulateHandleOp` is built into EntryPoint.sol itself
//! - **v0.7+**: `simulateHandleOp` is in a separate EntryPointSimulations.sol
//!
//! # State Override Strategy
//!
//! We use state overrides to deploy simulation bytecode at the EntryPoint address.
//! This allows gas estimation even when the EntryPoint is not yet deployed on-chain.
//!
//! # Building with Bytecode
//!
//! The contracts are git submodules in `contracts/solidity/`. To compile:
//!
//! ```sh
//! cd contracts/solidity/v0_6 && forge build
//! cd contracts/solidity/v0_7 && forge build
//! cd contracts/solidity/v0_8 && forge build
//! cd contracts/solidity/v0_9 && forge build
//! ```

mod bytecode;
pub mod v06;
pub mod v07;
pub mod v08;
pub mod v09;

// Re-export generated bytecode constants
pub use bytecode::{
    has_v06_bytecode, has_v07_bytecode, has_v08_bytecode, has_v09_bytecode,
    ENTRYPOINT_V06_SIMULATIONS_DEPLOYED_BYTECODE, ENTRYPOINT_V07_SIMULATIONS_DEPLOYED_BYTECODE,
    ENTRYPOINT_V08_SIMULATIONS_DEPLOYED_BYTECODE, ENTRYPOINT_V09_SIMULATIONS_DEPLOYED_BYTECODE,
};

pub use v06::*;
pub use v07::*;
pub use v08::*;
pub use v09::*;

use alloy_primitives::{Address, Bytes, U256};
use alloy_rpc_types_eth::state::{AccountOverride, StateOverride};

/// Creates a state override that deploys custom code at the specified address
pub fn create_code_override(address: Address, code: Bytes) -> StateOverride {
    let mut overrides = StateOverride::default();
    overrides.insert(
        address,
        AccountOverride {
            code: Some(code),
            ..Default::default()
        },
    );
    overrides
}

/// Creates a state override that sets balance for an address
pub fn create_balance_override(address: Address, balance: U256) -> StateOverride {
    let mut overrides = StateOverride::default();
    overrides.insert(
        address,
        AccountOverride {
            balance: Some(balance),
            ..Default::default()
        },
    );
    overrides
}

/// Merges multiple state overrides into one
pub fn merge_state_overrides(overrides: Vec<StateOverride>) -> StateOverride {
    let mut merged = StateOverride::default();
    for override_set in overrides {
        for (address, account_override) in override_set {
            merged.insert(address, account_override);
        }
    }
    merged
}

// ============================================================
// UserOperation Decoding from handleOps calldata
// ============================================================

use crate::entrypoint::{get_entrypoint_version, EntryPointVersion};
use crate::rpc::{UserOperation, UserOperationV06, UserOperationV07};
use alloy_sol_types::SolCall;

/// handleOps function selector for v0.6
/// keccak256("handleOps((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[],address)")
pub const HANDLE_OPS_V06_SELECTOR: [u8; 4] = [0x1f, 0xad, 0x94, 0x8c];

/// handleOps function selector for v0.7/v0.8
/// keccak256("handleOps((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes)[],address)")
pub const HANDLE_OPS_V07_SELECTOR: [u8; 4] = [0x76, 0x5e, 0x82, 0x7f];

/// Decode UserOperations from handleOps calldata
///
/// Returns a vector of UserOperations that can be hashed to match against a user_op_hash.
/// Supports v0.6, v0.7, and v0.8 EntryPoint versions.
pub fn decode_user_operations_from_calldata(
    calldata: &Bytes,
    entry_point: Address,
) -> Vec<UserOperation> {
    let version = match get_entrypoint_version(entry_point) {
        Some(v) => v,
        None => return Vec::new(),
    };

    if calldata.len() < 4 {
        return Vec::new();
    }

    let selector: [u8; 4] = calldata[..4].try_into().unwrap_or([0; 4]);

    match version {
        EntryPointVersion::V06 => {
            if selector == HANDLE_OPS_V06_SELECTOR {
                decode_handle_ops_v06(calldata)
            } else {
                Vec::new()
            }
        }
        EntryPointVersion::V07 | EntryPointVersion::V08 | EntryPointVersion::V09 => {
            if selector == HANDLE_OPS_V07_SELECTOR {
                decode_handle_ops_v07(calldata)
            } else {
                Vec::new()
            }
        }
    }
}

/// Decode v0.6 handleOps calldata
fn decode_handle_ops_v06(calldata: &Bytes) -> Vec<UserOperation> {
    use v06::IEntryPointV06;

    match IEntryPointV06::handleOpsCall::abi_decode(&calldata[..]) {
        Ok(decoded) => decoded
            .ops
            .into_iter()
            .map(|packed| {
                // Extract factory and paymaster from packed fields (used for debugging/future use)
                let (_factory, _factory_data) = if packed.initCode.len() >= 20 {
                    (
                        Some(Address::from_slice(&packed.initCode[..20])),
                        packed.initCode.slice(20..),
                    )
                } else {
                    (None, Bytes::default())
                };

                let (_paymaster, _paymaster_data) = if packed.paymasterAndData.len() >= 20 {
                    (
                        Some(Address::from_slice(&packed.paymasterAndData[..20])),
                        packed.paymasterAndData.slice(20..),
                    )
                } else {
                    (None, Bytes::default())
                };

                UserOperation::V06(UserOperationV06 {
                    sender: packed.sender,
                    nonce: packed.nonce,
                    init_code: packed.initCode,
                    call_data: packed.callData,
                    call_gas_limit: packed.callGasLimit,
                    verification_gas_limit: packed.verificationGasLimit,
                    pre_verification_gas: packed.preVerificationGas,
                    max_fee_per_gas: packed.maxFeePerGas,
                    max_priority_fee_per_gas: packed.maxPriorityFeePerGas,
                    paymaster_and_data: packed.paymasterAndData,
                    signature: packed.signature,
                })
            })
            .collect(),
        Err(_) => Vec::new(),
    }
}

/// Decode v0.7/v0.8 handleOps calldata
fn decode_handle_ops_v07(calldata: &Bytes) -> Vec<UserOperation> {
    use v07::IEntryPointV07;

    match IEntryPointV07::handleOpsCall::abi_decode(&calldata[..]) {
        Ok(decoded) => decoded
            .ops
            .into_iter()
            .map(|packed| {
                // Unpack gas limits from bytes32 (verificationGasLimit | callGasLimit)
                let account_gas_limits: [u8; 32] = packed.accountGasLimits.into();
                let verification_gas_limit =
                    U256::from_be_slice(&account_gas_limits[..16]);
                let call_gas_limit = U256::from_be_slice(&account_gas_limits[16..]);

                // Unpack gas fees from bytes32 (maxPriorityFeePerGas | maxFeePerGas)
                let gas_fees: [u8; 32] = packed.gasFees.into();
                let max_priority_fee_per_gas = U256::from_be_slice(&gas_fees[..16]);
                let max_fee_per_gas = U256::from_be_slice(&gas_fees[16..]);

                // Extract factory from initCode
                let (factory, factory_data) = if packed.initCode.len() >= 20 {
                    (
                        Address::from_slice(&packed.initCode[..20]),
                        packed.initCode.slice(20..),
                    )
                } else {
                    (Address::ZERO, Bytes::default())
                };

                // Extract paymaster from paymasterAndData
                // Format: paymaster (20) + verificationGasLimit (16) + postOpGasLimit (16) + data
                let (paymaster, pm_verification_gas, pm_post_op_gas, paymaster_data) =
                    if packed.paymasterAndData.len() >= 52 {
                        let pm = Address::from_slice(&packed.paymasterAndData[..20]);
                        let pm_ver_gas =
                            U256::from_be_slice(&packed.paymasterAndData[20..36]);
                        let pm_post_op_gas =
                            U256::from_be_slice(&packed.paymasterAndData[36..52]);
                        let pm_data = packed.paymasterAndData.slice(52..);
                        (pm, pm_ver_gas, pm_post_op_gas, pm_data)
                    } else if packed.paymasterAndData.len() >= 20 {
                        // Old format without gas limits
                        let pm = Address::from_slice(&packed.paymasterAndData[..20]);
                        let pm_data = packed.paymasterAndData.slice(20..);
                        (pm, U256::ZERO, U256::ZERO, pm_data)
                    } else {
                        (Address::ZERO, U256::ZERO, U256::ZERO, Bytes::default())
                    };

                UserOperation::V07(UserOperationV07 {
                    sender: packed.sender,
                    nonce: packed.nonce,
                    factory,
                    factory_data,
                    call_data: packed.callData,
                    call_gas_limit,
                    verification_gas_limit,
                    pre_verification_gas: packed.preVerificationGas,
                    max_fee_per_gas,
                    max_priority_fee_per_gas,
                    paymaster,
                    paymaster_verification_gas_limit: pm_verification_gas,
                    paymaster_post_op_gas_limit: pm_post_op_gas,
                    paymaster_data,
                    signature: packed.signature,
                })
            })
            .collect(),
        Err(_) => Vec::new(),
    }
}

/// Check if an address is a known EntryPoint address
pub fn is_entrypoint(address: Address) -> bool {
    address == ENTRYPOINT_V06_ADDRESS
        || address == ENTRYPOINT_V07_ADDRESS
        || address == ENTRYPOINT_V08_ADDRESS
        || address == ENTRYPOINT_V09_ADDRESS
}
